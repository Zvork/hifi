<!
//  DeferredTransform.slh
//  libraries/render-utils/src
//
//  Created by Sam Gateau on 6/2/16.
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not DEFERRED_TRANSFORM_SLH@>
<@def DEFERRED_TRANSFORM_SLH@>

<@func declareDeferredFrameTransform()@>

struct PresentFrame {
    mat4 _correction;
    mat4 _correctionInverse;
    
    mat4 _prevView;
    mat4 _prevViewInverse;

    ivec4 _frameIndex;
};
 
uniform presentFrameBuffer {
    PresentFrame presentFrame;
};

<@include DeferredTransform_shared.slh@>

#define DeferredFrameTransform _DeferredFrameTransform

uniform deferredFrameTransformBuffer {
    DeferredFrameTransform frameTransform;
};

vec2 getWidthHeight(int resolutionLevel) {
    return vec2(ivec2(frameTransform.pixelInfo.zw) >> resolutionLevel);
}

vec2 getInvWidthHeight() {
    return frameTransform.invPixelInfo.xy;
}

float getProjScaleEye() {
    return frameTransform.projection[0][1][1];
}

float getProjScale(int resolutionLevel) {
    return getWidthHeight(resolutionLevel).y * frameTransform.projection[0][1][1] * 0.5;
}
mat4 getProjection(int side) {
    return frameTransform.projection[side];
}
mat4 getProjectionMono() {
    return frameTransform.projectionMono;
}
mat4 getUnjitteredProjection(int side) {
	return frameTransform.projectionUnjittered[side];
}
mat4 getUnjitteredInvProjection(int side) {
	return frameTransform.invProjectionUnjittered[side];
}

// positive near distance of the projection
float getProjectionNear() {
    float planeC = frameTransform.projection[0][2][3] + frameTransform.projection[0][2][2];
    float planeD = frameTransform.projection[0][3][2];
    return planeD / planeC;
}

// positive far distance of the projection
float getPosLinearDepthFar() {
    return -frameTransform.depthInfo.z;
}

mat4 getViewInverse() {
    return frameTransform.invView * presentFrame._correctionInverse;
}

mat4 getView() {
    return presentFrame._correction * frameTransform.view;
}

mat4 getPreviousView() {
    return presentFrame._prevView;
}

mat4 getPreviousViewInverse() {
    return presentFrame._prevViewInverse;
}

DeferredFrameTransform getDeferredFrameTransform() {
    DeferredFrameTransform result = frameTransform;
    result.view = getView();  
    result.invView = getViewInverse();  
    return result;
}

bool isStereo() {
    return frameTransform.stereoInfo.x > 0.0f;
}

float getStereoSideWidth(int resolutionLevel) {
    return float(int(frameTransform.stereoInfo.y) >> resolutionLevel);
}
float getStereoSideHeight(int resolutionLevel) {
    return float(int(frameTransform.pixelInfo.w) >> resolutionLevel);
}

vec2 getSideImageSize(int resolutionLevel) {
    return vec2(float(int(frameTransform.stereoInfo.y) >> resolutionLevel), float(int(frameTransform.pixelInfo.w) >> resolutionLevel));
}

ivec4 getStereoSideInfo(int xPos, int resolutionLevel) {
    int sideWidth = int(getStereoSideWidth(resolutionLevel));
    return ivec4(xPos < sideWidth ? ivec2(0, 0) : ivec2(1, sideWidth), sideWidth, isStereo());
}

float evalZeyeFromZdb(float depth) {
    return frameTransform.depthInfo.x / (depth * frameTransform.depthInfo.y + frameTransform.depthInfo.z);
}

float evalZdbFromZeye(float Zeye) {
    return (frameTransform.depthInfo.x - Zeye * frameTransform.depthInfo.z) / (Zeye * frameTransform.depthInfo.y);
}

vec3 evalEyeNormal(vec3 C) {
    return normalize(cross(dFdx(C), dFdy(C)));
}

vec3 evalEyePositionFromZdb(int side, float Zdb, vec2 texcoord) {
    // compute the view space position using the depth
    vec3 clipPos;
    clipPos.xyz = vec3(texcoord.xy, Zdb) * 2.0 - 1.0;
    vec4 eyePos = frameTransform.invProjection[side] * vec4(clipPos.xyz, 1.0);
    return eyePos.xyz / eyePos.w;
}

vec3 evalUnjitteredEyePositionFromZdb(int side, float Zdb, vec2 texcoord) {
    // compute the view space position using the depth
    vec3 clipPos;
    clipPos.xyz = vec3(texcoord.xy, Zdb) * 2.0 - 1.0;
    vec4 eyePos = frameTransform.invProjectionUnjittered[side] * vec4(clipPos.xyz, 1.0);
    return eyePos.xyz / eyePos.w;
}

vec3 evalEyePositionFromZeye(int side, float Zeye, vec2 texcoord) {
	float Zdb = evalZdbFromZeye(Zeye);
    return evalEyePositionFromZdb(side, Zdb, texcoord);
}

ivec2 getPixelPosTexcoordPosAndSide(in vec2 glFragCoord, out ivec2 pixelPos, out vec2 texcoordPos, out ivec4 stereoSide) {
    ivec2 fragPos = ivec2(glFragCoord.xy);

    stereoSide = getStereoSideInfo(fragPos.x, 0);

    pixelPos = fragPos;
    pixelPos.x -= stereoSide.y;

    texcoordPos = (vec2(pixelPos) + 0.5) * getInvWidthHeight();
    
    return fragPos;
}

<@endfunc@>


<@endif@>