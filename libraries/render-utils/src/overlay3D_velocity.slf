<@include gpu/Config.slh@>
<$VERSION_HEADER$>
// <$_SCRIBE_FILENAME$> 
// Generated on <$_SCRIBE_DATE$>
//
//  Created by Olivier Prat on 5/29/18.
//  Copyright 2018 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//


<@include graphics/Light.slh@>
<$declareLightBuffer()$>
<$declareLightAmbientBuffer()$>

<@include LightingModel.slh@>

<@include LightDirectional.slh@>
<$declareLightingDirectional()$>

<@if not GPU_TRANSFORM_STATE_SLH@>
<@include gpu/Transform.slh@>
<$declareStandardCameraTransform()$>
<@endif@>

<@include DeferredBufferWrite.slh@>

vec4 evalGlobalColor(float shadowAttenuation, vec3 position, vec3 normal, vec3 albedo, float metallic, vec3 fresnel, float roughness, float opacity) {

    // Need the light now
    Light light = getKeyLight();
    vec3 lightDirection = getLightDirection(light);
    vec3 lightIrradiance = getLightIrradiance(light);

    LightAmbient ambient = getLightAmbient();

    TransformCamera cam = getTransformCamera();
    vec3 fragEyeVectorView = normalize(-position);
    vec3 fragEyeDir;
    <$transformEyeToWorldDir(cam, fragEyeVectorView, fragEyeDir)$>

    SurfaceData surface = initSurfaceData(roughness, normal, fragEyeDir);

    vec3 color = opacity * albedo * getLightColor(light) * getLightAmbientIntensity(ambient);

    // Directional
    vec3 directionalDiffuse;
    vec3 directionalSpecular;
    evalLightingDirectional(directionalDiffuse, directionalSpecular, lightDirection, lightIrradiance, surface, metallic, fresnel, albedo, shadowAttenuation);
    color += directionalDiffuse * isDiffuseEnabled() * isDirectionalEnabled();
    color += directionalSpecular * isSpecularEnabled() * isDirectionalEnabled();

    return vec4(color, opacity);
}

uniform sampler2D originalTexture;

in vec2 _texCoord0;
in vec4 _positionES;
in vec3 _normalWS;
in vec3 _color;
in float _alpha;
in vec4 _prevPositionCS;

void main(void) {
    vec4 albedo = texture(originalTexture, _texCoord0);

    vec3 fragPosition = _positionES.xyz;
    vec3 fragNormal = normalize(_normalWS);
    vec3 fragAlbedo = albedo.rgb * _color;
    float fragMetallic = 0.0;
    vec3 fragSpecular = vec3(0.1);
    float fragRoughness = 0.9;
    float fragOpacity = albedo.a;

    if (fragOpacity <= 0.1) {
        discard;
    }

    vec4 color = evalGlobalColor(1.0,
        fragPosition,
        fragNormal,
        fragAlbedo,
        fragMetallic,
        fragSpecular,
        fragRoughness,
        fragOpacity);

    packDeferredFragmentOverlay(_prevPositionCS, color);
}
