<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Sam Gondelman on 7/18/2018
//  Copyright 2018 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include gpu/Transform.slh@>
<$declareStandardTransform()$>

struct ParabolaData {
    vec3 velocity;
    float parabolicDistance;
    vec3 acceleration;
    float width;
    vec4 color;
    int numSections;
    ivec3 spare;
};

LAYOUT_STD140(binding=0) uniform parabolaData {
    ParabolaData _parabolaData;
};

layout(location=0) out vec4 _color;
layout(location=1) out vec4 _prevPositionCS;

void main(void) {
    _color = _parabolaData.color;

    float t = _parabolaData.parabolicDistance * (float(gl_VertexID / 2) / float(_parabolaData.numSections));

    vec4 pos = vec4(_parabolaData.velocity * t + 0.5 * _parabolaData.acceleration * t * t, 1);
    vec4 prevPos = pos;
    const float EPSILON = 0.00001;
    vec4 normal;
    vec4 prevNormal;

    TransformCamera cam = getTransformCamera();
    TransformObject obj = getTransformObject();
    if (dot(_parabolaData.acceleration, _parabolaData.acceleration) < EPSILON) {
        // Handle case where acceleration == (0, 0, 0)
        vec3 eyeUp = vec3(0, 1, 0);
        vec3 worldUp;
        vec3 prevWorldUp;
        <$transformEyeToWorldDir(cam, eyeUp, worldUp)$>
        <$transformEyeToPreviousWorldDir(cam, eyeUp, prevWorldUp)$>
        normal = vec4(normalize(cross(_parabolaData.velocity, worldUp)), 0);
        prevNormal = vec4(normalize(cross(_parabolaData.velocity, prevWorldUp)), 0);
    } else {
        normal = vec4(normalize(cross(_parabolaData.velocity, _parabolaData.acceleration)), 0);
        prevNormal = normal;
    }
    if (gl_VertexID % 2 == 0) {
        pos += 0.5 * _parabolaData.width * normal;
        prevPos += 0.5 * _parabolaData.width * prevNormal;
    } else {
        pos -= 0.5 * _parabolaData.width * normal;
        prevPos -= 0.5 * _parabolaData.width * prevNormal;
    }

    <$transformModelToClipPosAndPreviousClipPos(cam, obj, pos, gl_Position, _prevPositionCS)$>
}