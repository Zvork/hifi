<!
//  DeferredBufferWrite.slh
//  libraries/render-utils/src
//
//  Created by Sam Gateau on 1/12/15.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not DEFERRED_BUFFER_WRITE_SLH@>
<@def DEFERRED_BUFFER_WRITE_SLH@>

<@include DeferredBuffer.slh@>
<@include DeferredBufferWrite_shared.slh@>

layout(location = DEFERRED_COLOR_SLOT) out vec4 _fragColor0;
layout(location = DEFERRED_NORMAL_SLOT) out vec4 _fragColor1;
layout(location = DEFERRED_SPECULAR_SLOT) out vec4 _fragColor2;
layout(location = DEFERRED_VELOCITY_SLOT) out vec4 _fragColor3;

layout(location = DEFERRED_LIGHTING_SLOT) out vec4 _lighting;

// the alpha threshold
const float alphaThreshold = 0.5;
float evalOpaqueFinalAlpha(float alpha, float mapAlpha) {
    return mix(alpha, 1.0 - alpha, step(mapAlpha, alphaThreshold));
}

<@include DeferredTransform.slh@>
<$declareDeferredFrameTransform()$>

vec2 packVelocity(vec3 positionWS) {
    ivec2 pixelPos;
    vec2 texcoordPos;
    ivec4 stereoSide;
    ivec2 framePixelPos = getPixelPosTexcoordPosAndSide(gl_FragCoord.xy, pixelPos, texcoordPos, stereoSide);

    vec3 prevEyePos = (getPreviousView() * vec4(positionWS, 1.0)).xyz;
    vec4 prevClipPos = (getUnjitteredProjection(stereoSide.x) * vec4(prevEyePos, 1.0));
    vec2 prevUV =  0.5 * (prevClipPos.xy / prevClipPos.w) + vec2(0.5);

    vec2 deltaUV = texcoordPos - prevUV;

    return deltaUV;
}

<@include DefaultMaterials.slh@>
<@include LightingModel.slh@>

void packDeferredFragment(vec3 positionWS, vec3 normal, float alpha, vec3 albedo, float roughness, float metallic, vec3 emissive, float occlusion, float scattering) {
    if (alpha != 1.0) {
        discard;
    }
    _fragColor0 = vec4(albedo, ((scattering > 0.0) ? packScatteringMetallic(metallic) : packShadedMetallic(metallic)));
    _fragColor1 = vec4(packNormal(normal), clamp(roughness, 0.0, 1.0));
    _fragColor2 = vec4(((scattering > 0.0) ? vec3(scattering) : emissive), occlusion);
    _fragColor3 = vec4(packVelocity(positionWS), 0.0, 0.0);
    
    _lighting = vec4(isEmissiveEnabled() * emissive, 1.0);
}

void packDeferredFragmentLightmap(vec3 positionWS, vec3 normal, float alpha, vec3 albedo, float roughness, float metallic, vec3 fresnel, vec3 lightmap) {
    if (alpha != 1.0) {
        discard;
    }

    _fragColor0 = vec4(albedo, packLightmappedMetallic(metallic));
    _fragColor1 = vec4(packNormal(normal), clamp(roughness, 0.0, 1.0));
    _fragColor2 = vec4(isLightmapEnabled() * lightmap, 1.0);
    _fragColor3 = vec4(packVelocity(positionWS), 0.0, 0.0);

    _lighting = vec4(isLightmapEnabled() * lightmap * albedo, 1.0);
}

void packDeferredFragmentUnlit(vec3 positionWS, vec3 normal, float alpha, vec3 color) {
    if (alpha != 1.0) {
        discard;
    }
    _fragColor0 = vec4(color, packUnlit());
    _fragColor1 = vec4(packNormal(normal), 1.0);
    _fragColor3 = vec4(packVelocity(positionWS), 0.0, 0.0);
    _lighting = vec4(color, 1.0);
}

void packDeferredFragmentTranslucent(vec3 normal, float alpha, vec3 albedo, vec3 fresnel, float roughness) {
    if (alpha <= 0.0) {
        discard;
    }
    _fragColor0 = vec4(albedo.rgb, alpha);
    _fragColor1 = vec4(packNormal(normal), clamp(roughness, 0.0, 1.0));

}

<@endif@>
